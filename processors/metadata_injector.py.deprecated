#!/usr/bin/env python3
"""
Metadata æ³¨å…¥å™¨
ç¬¦åˆ rag_data_washer è¦å‰‡
"""

import re
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

try:
    from opencc import OpenCC
    OPENCC_AVAILABLE = True
except ImportError:
    OPENCC_AVAILABLE = False


class MetadataInjector:
    """Metadata æ³¨å…¥å™¨"""
    
    # è¡“èªè½‰æ› (ç°¡é«” â†’ ç¹é«”å•†æ¥­è¡“èª)
    TERM_MAPPINGS = {
        "å•†ä¸šæ¨¡å¼": "å•†æ¥­æ¨¡å¼",
        "å¿ƒæ™ºä»½é¢": "å¿ƒæ™ºä½”æœ‰ç‡",
        "ç§åŸŸæµé‡": "ç§åŸŸæµé‡æ± ",
        "æ–œæ é’å¹´": "æ–œæ§“é’å¹´",
        "ä¸ªäººIP": "å€‹äººIP",
        "å®šä½": "å®šä½",
        "å·®å¼‚åŒ–": "å·®ç•°åŒ–",
        "å¤è´­": "å¾©è³¼",
        "è·å®¢": "ç²å®¢",
        "ç”¨æˆ·ç”»åƒ": "ç”¨æˆ¶ç•«åƒ",
        "ç—›ç‚¹": "ç—›é»",
        "çˆ†æ¬¾": "çˆ†æ¬¾",
        "å˜ç°": "è®Šç¾",
        "æµé‡æ± ": "æµé‡æ± ",
        "è£‚å˜": "è£‚è®Š",
        "ç§è‰": "ç¨®è‰",
        "å¸¦è´§": "å¸¶è²¨",
    }
    
    def __init__(self):
        if OPENCC_AVAILABLE:
            self.cc = OpenCC('s2twp')  # ç°¡é«” â†’ ç¹é«” (å°ç£åå¥½)
        else:
            self.cc = None
    
    def convert_to_traditional(self, text: str) -> str:
        """è½‰æ›ç‚ºç¹é«”ä¸­æ–‡"""
        if self.cc:
            text = self.cc.convert(text)
        
        # æ‡‰ç”¨è¡“èªè½‰æ›
        for simplified, traditional in self.TERM_MAPPINGS.items():
            text = text.replace(simplified, traditional)
        
        return text
    
    def generate_metadata(self, 
                          title: str,
                          author: str = None,
                          source: str = None,
                          platform: str = None,
                          url: str = None,
                          duration: str = None,
                          speakers: List[Dict] = None,
                          keywords: List[str] = None,
                          summary: str = None,
                          knowledge_points: List[str] = None,
                          tags: List[str] = None) -> str:
        """
        ç”Ÿæˆ YAML frontmatter
        
        Returns:
            YAML æ ¼å¼çš„ metadata
        """
        metadata = ["---"]
        
        # åŸºæœ¬è³‡è¨Š
        metadata.append(f'title: "{self._escape_yaml(title)}"')
        
        if author:
            metadata.append(f'author: "{self._escape_yaml(author)}"')
        
        metadata.append(f'date: "{datetime.now().strftime("%Y-%m-%d")}"')
        
        if source:
            metadata.append(f'source: "{self._escape_yaml(source)}"')
        
        if platform:
            metadata.append(f'platform: "{platform}"')
        
        if url:
            metadata.append(f'url: "{url}"')
        
        if duration:
            metadata.append(f'duration: "{duration}"')
        
        # è¬›è€…è³‡è¨Š
        if speakers:
            metadata.append("speakers:")
            for speaker in speakers:
                metadata.append(f'  - role: "{speaker.get("role", "unknown")}"')
                metadata.append(f'    name: "{self._escape_yaml(speaker.get("name", ""))}"')
        
        # é—œéµå­—å’Œæ¨™ç±¤
        if keywords:
            keywords_str = ", ".join([f'"{k}"' for k in keywords[:10]])
            metadata.append(f'keywords: [{keywords_str}]')
        
        if tags:
            tags_str = ", ".join([f'"{t}"' for t in tags[:5]])
            metadata.append(f'tags: [{tags_str}]')
        
        # æ‘˜è¦
        if summary:
            summary = self._escape_yaml(summary)
            metadata.append(f'summary: "{summary}"')
        
        # çŸ¥è­˜é»
        if knowledge_points:
            metadata.append("knowledge_points:")
            for point in knowledge_points[:5]:
                metadata.append(f'  - "{self._escape_yaml(point)}"')
        
        # è™•ç†æ™‚é–“
        metadata.append(f'last_processed: "{datetime.now().isoformat()}"')
        
        metadata.append("---")
        
        return '\n'.join(metadata)
    
    def _escape_yaml(self, text: str) -> str:
        """è½‰ç¾© YAML ç‰¹æ®Šå­—ç¬¦"""
        if not text:
            return ""
        # ç§»é™¤æ›è¡Œç¬¦
        text = text.replace('\n', ' ').replace('\r', '')
        # è½‰ç¾©å¼•è™Ÿ
        text = text.replace('"', '\\"')
        return text
    
    def create_markdown(self,
                        content: str,
                        knowledge: str,
                        metadata_kwargs: Dict) -> str:
        """
        å‰µå»ºå®Œæ•´çš„ Markdown æ–‡ä»¶
        
        Args:
            content: åŸå§‹å…§å®¹ (é€å­—ç¨¿)
            knowledge: æå–çš„çŸ¥è­˜
            metadata_kwargs: metadata åƒæ•¸
            
        Returns:
            å®Œæ•´çš„ Markdown å…§å®¹
        """
        # ç”Ÿæˆ metadata
        metadata = self.generate_metadata(**metadata_kwargs)
        
        # è½‰æ›ç‚ºç¹é«”
        content = self.convert_to_traditional(content)
        knowledge = self.convert_to_traditional(knowledge)
        
        # çµ„åˆæ–‡ä»¶
        markdown_parts = [
            metadata,
            "",
            "## å•†æ¥­çŸ¥è­˜æå–",
            "",
            knowledge,
            "",
            "---",
            "",
            "## åŸå§‹é€å­—ç¨¿",
            "",
            content,
        ]
        
        return '\n'.join(markdown_parts)
    
    def generate_safe_filename(self, title: str, max_length: int = 80) -> str:
        """
        ç”Ÿæˆå®‰å…¨çš„æª”å
        
        Args:
            title: åŸå§‹æ¨™é¡Œ
            max_length: æœ€å¤§é•·åº¦
            
        Returns:
            å®‰å…¨çš„æª”å (ä¸å«å‰¯æª”å)
        """
        # ç§»é™¤ç‰¹æ®Šå­—ç¬¦
        safe_title = re.sub(r'[\\/*?:"<>|]', '_', title)
        # ç§»é™¤é€£çºŒç©ºç™½
        safe_title = re.sub(r'\s+', '_', safe_title)
        # è½‰æ›ç‚ºå°å¯«è›‡å½¢å‘½å
        safe_title = safe_title.lower()
        # é™åˆ¶é•·åº¦
        if len(safe_title) > max_length:
            safe_title = safe_title[:max_length]
        # ç§»é™¤å°¾éƒ¨ä¸‹åŠƒç·š
        safe_title = safe_title.rstrip('_')
        
        return safe_title


if __name__ == "__main__":
    print("ğŸ“ Crawl_R2R Metadata Injector")
    print("=" * 50)
    
    injector = MetadataInjector()
    
    # æ¸¬è©¦
    metadata = injector.generate_metadata(
        title="å‰µæ¥­è€…å¿…çœ‹ï¼šå•†æ¥­æ¨¡å¼è¨­è¨ˆ",
        author="å¼µä¸‰",
        source="Dan Koe",
        platform="youtube",
        url="https://youtube.com/watch?v=xxx",
        duration="15:30",
        speakers=[
            {"role": "host", "name": "ä¸»æŒäºº"},
            {"role": "guest", "name": "å¼µä¸‰"}
        ],
        keywords=["å•†æ¥­æ¨¡å¼", "å‰µæ¥­", "å®šä½"],
        summary="æœ¬æœŸç¯€ç›®æ¢è¨å•†æ¥­æ¨¡å¼è¨­è¨ˆçš„æ ¸å¿ƒè¦ç´ ",
        tags=["å‰µæ¥­", "å•†æ¥­æ¨¡å¼"]
    )
    
    print("ç”Ÿæˆçš„ Metadata:")
    print(metadata)
    
    # æ¸¬è©¦ç¹ç°¡è½‰æ›
    test_text = "ç§åŸŸæµé‡æ˜¯ä¸€ä¸ªé‡è¦çš„å•†ä¸šæ¨¡å¼"
    converted = injector.convert_to_traditional(test_text)
    print(f"\nç¹ç°¡è½‰æ›: {test_text} â†’ {converted}")
